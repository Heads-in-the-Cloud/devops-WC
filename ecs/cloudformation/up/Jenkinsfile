pipeline {
    agent any 

    stages {
        stage('Setup parameters') {
            steps {
                script { 
                    properties([
                        parameters([
                            choice(
                                choices: ['dev', 'prod', 'test'], 
                                name: 'environment'
                            ),
                            [$class: 'ChoiceParameter', 
                                choiceType: 'PT_SINGLE_SELECT', 
                                description: 'Select the action to perform', 
                                filterLength: 1, 
                                filterable: false, 
                                name: 'action', 
                                script: [
                                    $class: 'GroovyScript', 
                                    fallbackScript: [
                                        classpath: [], 
                                        sandbox: false, 
                                        script: 
                                            "return['Could not load actions']"
                                    ], 
                                    script: [
                                        classpath: [], 
                                        sandbox: false, 
                                        script: 
                                            "return['create','update']"
                                    ]
                                ]
                            ],
                            [$class: 'CascadeChoiceParameter', 
                                choiceType: 'PT_SINGLE_SELECT', 
                                description: 'Select the container to update',
                                name: 'container', 
                                referencedParameters: 'action', 
                                script: 
                                    [$class: 'GroovyScript', 
                                    fallbackScript: [
                                            classpath: [], 
                                            sandbox: false, 
                                            script: "return['Could not get Environment from Env Param']"
                                            ], 
                                    script: [
                                            classpath: [], 
                                            sandbox: false, 
                                            script: '''
                                            if (action.equals("create")){
                                                return[]
                                            }
                                            else{
                                                return["users","flights","bookings","frontend"]
                                            }
                                            '''
                                    ] 
                                ]
                            ]
                        ])
                    ])
                }
            }
        }

        stage('setup environment'){
            steps{
                script{
                    dir('ecs/cloudformation/up'){
                        env.AWS_DEFAULT_REGION  = "$REGION_WC"
                        env.VPC_ID              = sh (script: "aws ec2 describe-vpcs --filter Name=tag:Name,Values=${WC_vpc_name}-dev | jq '.[] | .[].VpcId'", returnStdout: true).trim().replaceAll("\"", "")
                        env.PRIVATE_SUBNET1     = sh( script: "aws ec2 describe-subnets --filters Name=vpc-id,Values=${VPC_ID} Name=tag:kubernetes.io/role/internal-elb,Values=1 --query Subnets[].SubnetId | jq '.[0]'", returnStdout: true).trim()
                        env.PRIVATE_SUBNET2     = sh( script: "aws ec2 describe-subnets --filters Name=vpc-id,Values=${VPC_ID} Name=tag:kubernetes.io/role/internal-elb,Values=1 --query Subnets[].SubnetId | jq '.[1]'", returnStdout: true).trim()
                        env.PUBLIC_SUBNET1      = sh( script: "aws ec2 describe-subnets --filters Name=vpc-id,Values=${VPC_ID} Name=tag:kubernetes.io/role/elb,Values=1 --query Subnets[].SubnetId | jq '.[0]'", returnStdout: true).trim()
                        env.PUBLIC_SUBNET2      = sh( script: "aws ec2 describe-subnets --filters Name=vpc-id,Values=${VPC_ID} Name=tag:kubernetes.io/role/elb,Values=1 --query Subnets[].SubnetId | jq '.[1]'", returnStdout: true).trim()
                        env.STACK_NAME          = "${CF_STACK_WC}-${params.environment}"
                        env.STACK_EXISTS        = true
                        sh "envsubst < .env > temp"
                        sh "cat temp"
                    }
                }
            }
        }
        stage('check if stack exists'){
            steps{
                script {
                    try {
                        sh "aws cloudformation describe-stacks --stack-name ${STACK_NAME}"
                    }
                    catch (Exception e){
                        env.STACK_EXISTS        = false
                    }
                }
            }
        }
        stage('update users'){
            when {
                allOf{ 
                    expression { params.container == 'users' }
                    environment name: "STACK_EXISTS", value: 'true'
                }
            }
            steps{
                script{
                    sh "aws ecs update-service --service ${USER_REPO_WC} --task-definition ${USER_REPO_WC}-${params.environment} --force-new-deployment --cluster ${CLUSTER_NAME_WC}"
                }
            }
        }
        stage('update flights'){
            when {
                allOf{ 
                    expression { params.container == 'flights' }
                    environment name: "STACK_EXISTS", value: 'true'
                }
            }
            steps{
                script{
                    sh "aws ecs update-service --service ${FLIGHT_REPO_WC} --task-definition ${FLIGHT_REPO_WC}-${params.environment} --force-new-deployment --cluster ${CLUSTER_NAME_WC}"
                }
            }
        }
        stage('update bookings'){
            when {
                allOf{ 
                    expression { params.container == 'bookings' }
                    environment name: "STACK_EXISTS", value: 'true'
                }
            }
            steps{
                script{
                    sh "aws ecs update-service --service ${BOOKING_REPO_WC} --task-definition ${BOOKING_REPO_WC}-${params.environment} --force-new-deployment --cluster ${CLUSTER_NAME_WC}"
                }
            }
        }
        stage('update frontend'){
            when {
                allOf{ 
                    expression { params.container == 'frontend' }
                    environment name: "STACK_EXISTS", value: 'true'
                }
            }
            steps{
                script{
                    sh "aws ecs update-service --service ${FRONTEND_REPO_WC} --task-definition ${FRONTEND_REPO_WC}-${params.environment} --force-new-deployment --cluster ${CLUSTER_NAME_WC}"
                }
            }
        }
        stage('create'){
            when{
                environment name: 'STACK_EXISTS', value: 'false'
            }
            steps{
                dir('ecs/cloudformation/up'){
                    sh "aws cloudformation deploy --stack-name ${STACK_NAME} --template-file ./template.yaml --parameter-overrides file://.env"
                }
            }
        }
    }
}